<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>Haskell/Category theory - Wikibooks, open books for an open world</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.21wmf9" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="/w/index.php?title=Haskell/Category_theory&amp;action=edit" />
<link rel="edit" title="Edit" href="/w/index.php?title=Haskell/Category_theory&amp;action=edit" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikibooks (en)" />
<link rel="EditURI" type="application/rsd+xml" href="//en.wikibooks.org/w/api.php?action=rsd" />
<link rel="copyright" href="//creativecommons.org/licenses/by-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="Wikibooks Atom feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=ext.flaggedRevs.basic%7Cext.gadget.extlinks%7Cext.wikihiero%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmw.PopUpMediaTransform%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: enwikibooks:resourceloader:filter:minify-css:7:7e437ef773c7cbb07b329889319b1d5c */</style>

<script src="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Haskell/Category_theory","wgTitle":"Haskell/Category theory","wgCurRevisionId":2432486,"wgArticleId":107278,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Haskell"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Haskell/Category_theory","wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"editwarning":true,"expandablesearch":false,"footercleanup":false,"sectioneditlinks":false,"experiments":true},"wgWikiEditorEnabledModules":{"toolbar":true,"dialogs":true,"hidesig":true,"templateEditor":false,"templates":false,"preview":false,"previewDialog":false,"publish":false,"toc":false},"wgFlaggedRevsParams":{"tags":{"value":{"levels":3,"quality":2,"pristine":3}}},"wgStableRevisionId":2432486,"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}","Geo":{"city":"","country":""},"wgNoticeProject":"wikibooks"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":0,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":false,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":4,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":1,"watchdefault":0,"watchdeletion":0,"watchlistdays":3
,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"flaggedrevssimpleui":0,"flaggedrevsstable":0,"flaggedrevseditdiffs":true,"flaggedrevsviewdiffs":false,"vector-simplesearch":1,"useeditwarning":1,"vector-collapsiblenav":1,"usebetatoolbar":1,"usebetatoolbar-cgd":1,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":true,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"searchNs102":false,"searchNs103":false,"searchNs108":false,"searchNs109":false,"searchNs110":false,"searchNs111":false,"searchNs112":true,"searchNs113":false,"gadget-extlinks":1,"gadget-commons-file":1,"gadget-toolboxcompat":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.
tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: enwikibooks:resourceloader:filter:minify-js:7:71d2543b236ad98d29cc1ed0e44b8b72 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","ext.centralNotice.bannerController"]);
}</script>
<script src="//bits.wikimedia.org/geoiplookup"></script><link rel="dns-prefetch" href="//meta.wikimedia.org" /><!--[if lt IE 7]><style type="text/css">body{behavior:url("/w/skins-1.21wmf9/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Haskell_Category_theory skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- sitenotice -->
			<div id="siteNotice"><!-- CentralNotice --><script>
	mw.loader.using( 'ext.centralNotice.bannerController', function() { mw.centralNotice.initialize(); } );
</script>
</div>
			<!-- /sitenotice -->
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading" lang="en"><span dir="auto">Haskell/Category theory</span></h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From Wikibooks, open books for an open world</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"><span class="subpages">&lt; <a href="/wiki/Haskell" title="Haskell">Haskell</a></span></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>﻿</p>
<div class="noprint">
<table cellpadding="1" style="float: right; clear: right; border: 1px solid #8888aa; background: #f7f8ff; padding: 5px; font-size: 95%; margin: 0 15px 0 15px;">
<tr>
<td style="background: #ccf; text-align: center;"><b>Category theory</b> (<a href="/w/index.php?title=Haskell/Solutions/Category_theory&amp;action=edit&amp;redlink=1" class="new" title="Haskell/Solutions/Category theory (does not exist)">Solutions</a>)</td>
</tr>
<tr>
<td>
<table id="toc" class="toc">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction_to_categories"><span class="tocnumber">1</span> <span class="toctext">Introduction to categories</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Category_laws"><span class="tocnumber">1.1</span> <span class="toctext">Category laws</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Hask.2C_the_Haskell_category"><span class="tocnumber">1.2</span> <span class="toctext"><b>Hask</b>, the Haskell category</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Functors"><span class="tocnumber">2</span> <span class="toctext">Functors</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Functors_on_Hask"><span class="tocnumber">2.1</span> <span class="toctext">Functors on <b>Hask</b></span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Translating_categorical_concepts_into_Haskell"><span class="tocnumber">2.2</span> <span class="toctext">Translating categorical concepts into Haskell</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Monads"><span class="tocnumber">3</span> <span class="toctext">Monads</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Example:_the_powerset_functor_is_also_a_monad"><span class="tocnumber">3.1</span> <span class="toctext">Example: the powerset functor is also a monad</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#The_monad_laws_and_their_importance"><span class="tocnumber">4</span> <span class="toctext">The monad laws and their importance</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#The_first_law"><span class="tocnumber">4.1</span> <span class="toctext">The first law</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#The_second_law"><span class="tocnumber">4.2</span> <span class="toctext">The second law</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#The_third_and_fourth_laws"><span class="tocnumber">4.3</span> <span class="toctext">The third and fourth laws</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Application_to_do-blocks"><span class="tocnumber">4.4</span> <span class="toctext">Application to do-blocks</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Summary"><span class="tocnumber">5</span> <span class="toctext">Summary</span></a></li>
<li class="toclevel-1"><a href="#Notes"><span class="tocnumber">6</span> <span class="toctext">Notes</span></a></li>
</ul>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="background: #ccf; text-align: center;"><b>Wider Theory</b></td>
</tr>
<tr>
<td>
<p><a href="/wiki/Haskell/Denotational_semantics" title="Haskell/Denotational semantics">Denotational semantics</a> <a href="/wiki/File:75%25.svg" class="image"><img alt="75%.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/49/75%25.svg/9px-75%25.svg.png" width="9" height="9" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/49/75%25.svg/14px-75%25.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/49/75%25.svg/18px-75%25.svg.png 2x" /></a><br />
<a href="/w/index.php?title=Haskell/Equational_reasoning&amp;action=edit&amp;redlink=1" class="new" title="Haskell/Equational reasoning (does not exist)">Equational reasoning</a><br />
<a href="/w/index.php?title=Haskell/Program_derivation&amp;action=edit&amp;redlink=1" class="new" title="Haskell/Program derivation (does not exist)">Program derivation</a><br />
<strong class="selflink">Category theory</strong> <a href="/wiki/File:100%25.svg" class="image"><img alt="100%.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/9px-100%25.svg.png" width="9" height="9" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/14px-100%25.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/18px-100%25.svg.png 2x" /></a><br />
<a href="/wiki/Haskell/The_Curry-Howard_isomorphism" title="Haskell/The Curry-Howard isomorphism">The Curry-Howard isomorphism</a><br />
<a href="/wiki/Haskell/Fix_and_recursion" title="Haskell/Fix and recursion">fix and recursion</a> <a href="/wiki/File:100%25.svg" class="image"><img alt="100%.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/9px-100%25.svg.png" width="9" height="9" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/14px-100%25.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/18px-100%25.svg.png 2x" /></a></p>
<div style="clear:both;"><small class="noprint"><a class="external text" href="//en.wikibooks.org/w/index.php?title=Template:Haskell_chapter/Wider_Theory&amp;action=edit">edit this chapter</a></small></div>
</td>
</tr>
</table>
</div>
<p>This article attempts to give an overview of category theory, in so far as it applies to Haskell. To this end, Haskell code will be given alongside the mathematical definitions. Absolute rigour is not followed; in its place, we seek to give the reader an intuitive feel for what the concepts of category theory are and how they relate to Haskell.</p>
<h2><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=1" title="Edit section: Introduction to categories">edit</a>]</span> <span class="mw-headline" id="Introduction_to_categories">Introduction to categories</span></h2>
<div class="thumb tleft">
<div class="thumbinner" style="width:180px;"><a href="/wiki/File:Simple-cat.png" class="image"><img alt="" src="//upload.wikimedia.org/wikibooks/en/d/d3/Simple-cat.png" width="178" height="161" class="thumbimage" /></a>
<div class="thumbcaption">A simple category, with three objects <i>A</i>, <i>B</i> and <i>C</i>, three identity morphisms <img class="tex" alt="\mathit{id}_A" src="//upload.wikimedia.org/math/f/6/a/f6aa295bd1c49eee7997dd80cd776a04.png" />, <img class="tex" alt="\mathit{id}_B" src="//upload.wikimedia.org/math/8/4/e/84ee7854d793ec3f4eb96c7419353326.png" /> and <img class="tex" alt="\mathit{id}_C" src="//upload.wikimedia.org/math/6/f/d/6fd03b3aabef7cc412c93ade40915242.png" />, and two other morphisms <img class="tex" alt="f&#160;: C \to B" src="//upload.wikimedia.org/math/a/e/4/ae401422ac137754f0566efec797a5d1.png" /> and <img class="tex" alt="g&#160;: A \to B" src="//upload.wikimedia.org/math/0/f/5/0f51f35356c1551c8ddfbf151270fca9.png" />. The third element (the specification of how to compose the morphisms) is not shown.</div>
</div>
</div>
<p>A category is, in essence, a simple collection. It has three components:</p>
<ul>
<li>A collection of <b>objects</b>.</li>
<li>A collection of <b>morphisms</b>, each of which ties two objects (a <i>source object</i> and a <i>target object</i>) together. (These are sometimes called <b>arrows</b>, but we avoid that term here as it has other connotations in Haskell.) If <i>f</i> is a morphism with source object <i>A</i> and target object <i>B</i>, we write <img class="tex" alt="f&#160;: A \to B" src="//upload.wikimedia.org/math/e/0/f/e0fcfcf1bc30612af09825187fbbad7d.png" />.</li>
<li>A notion of <b>composition</b> of these morphisms. If <i>h</i> is the composition of morphisms <i>f</i> and <i>g</i>, we write <img class="tex" alt="h = f \circ g" src="//upload.wikimedia.org/math/9/6/8/9689c70813c468828574557543d6a7df.png" />.</li>
</ul>
<p>Lots of things form categories. For example, <b>Set</b> is the category of all sets with morphisms as standard functions and composition being standard function composition. (Category names are often typeset in bold face.) <b>Grp</b> is the category of all groups with morphisms as functions that preserve group operations (the group homomorphisms), i.e. for any two groups <i>G</i> with operation <i>*</i> and <i>H</i> with operation <i>·</i>, a function <img class="tex" alt="f&#160;: G \to H" src="//upload.wikimedia.org/math/c/c/4/cc4706c72fbc8394d04995b98ece6d74.png" /> is a morphism in <b>Grp</b> iff:</p>
<dl>
<dd><img class="tex" alt="f(u * v) = f(u) \cdot f(v)" src="//upload.wikimedia.org/math/d/a/f/dafebb4aa870654b4a5d1fe429ec2a34.png" /></dd>
</dl>
<p>It may seem that morphisms are always functions, but this needn't be the case. For example, any partial order (<i>P</i>, <img class="tex" alt="\leq" src="//upload.wikimedia.org/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png" />) defines a category where the objects are the elements of <i>P</i>, and there is a morphism between any two objects <i>A</i> and <i>B</i> iff <img class="tex" alt="A \leq B" src="//upload.wikimedia.org/math/7/f/3/7f38ddf9cb9fabdcda877c26e5bdc45c.png" />. Moreover, there are allowed to be multiple morphisms with the same source and target objects; using the <b>Set</b> example, <img class="tex" alt="\sin" src="//upload.wikimedia.org/math/8/8/2/88265cd42f61bdf16ef2bd9fada9d5cd.png" /> and <img class="tex" alt="\cos" src="//upload.wikimedia.org/math/1/f/1/1f141abfb260b11b18ca7ace446d349f.png" /> are both functions with source object <img class="tex" alt="\mathbb{R}" src="//upload.wikimedia.org/math/1/3/4/134676911181af05d24d406f16edf587.png" /> and target object <img class="tex" alt="[-1,1]" src="//upload.wikimedia.org/math/d/0/6/d060b17b29e0dae91a1cac23ea62281a.png" />, but they’re most certainly not the same morphism!</p>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=2" title="Edit section: Category laws">edit</a>]</span> <span class="mw-headline" id="Category_laws">Category laws</span></h3>
<p>There are three laws that categories need to follow. Firstly, and most simply, the composition of morphisms needs to be <i><b>associative</b></i>. Symbolically,</p>
<dl>
<dd><img class="tex" alt="f \circ (g \circ h) = (f \circ g) \circ h" src="//upload.wikimedia.org/math/8/e/d/8ed1736782512950ef2dede7b7942381.png" /></dd>
</dl>
<p>Secondly, the category needs to be <i><b>closed</b></i> under the composition operation. So if <img class="tex" alt="f&#160;: B \to C" src="//upload.wikimedia.org/math/1/4/3/14383088edfbcfeed421ecbced6603e2.png" /> and <img class="tex" alt="g&#160;: A \to B" src="//upload.wikimedia.org/math/0/f/5/0f51f35356c1551c8ddfbf151270fca9.png" />, then there must be some morphism <img class="tex" alt="h&#160;: A \to C" src="//upload.wikimedia.org/math/1/2/2/122dc175dba40f5732d272b3a4c80c2c.png" /> in the category such that <img class="tex" alt="h = f \circ g" src="//upload.wikimedia.org/math/9/6/8/9689c70813c468828574557543d6a7df.png" />. We can see how this works using the following category:</p>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Composition-ex.png" class="image"><img alt="Composition-ex.png" src="//upload.wikimedia.org/wikibooks/en/2/26/Composition-ex.png" width="413" height="105" /></a></div>
</div>
<p><i>f</i> and <i>g</i> are both morphisms so we must be able to compose them and get another morphism in the category. So which is the morphism <img class="tex" alt="f \circ g" src="//upload.wikimedia.org/math/9/d/d/9dd6c05179403906880d2c028164cea8.png" />? The only option is <img class="tex" alt="\mathit{id}_A" src="//upload.wikimedia.org/math/f/6/a/f6aa295bd1c49eee7997dd80cd776a04.png" />. Similarly, we see that <img class="tex" alt="g \circ f = \mathit{id}_B" src="//upload.wikimedia.org/math/d/0/2/d02e6fd72fa890da8f99ae53b5e33395.png" />.</p>
<p>Lastly, given a category <i>C</i> there needs to be for every object <code>A</code> an <i><b>identity</b> morphism</i>, <img class="tex" alt="\mathit{id}_A&#160;: A \to A" src="//upload.wikimedia.org/math/5/0/1/50122aee0bccae09e56a6b25c068cc3d.png" /> that is an identity of composition with other morphisms. Put precisely, for every morphism <img class="tex" alt="g&#160;: A \to B" src="//upload.wikimedia.org/math/0/f/5/0f51f35356c1551c8ddfbf151270fca9.png" />:</p>
<dl>
<dd><img class="tex" alt="g \circ \mathit{id}_A = \mathit{id}_B \circ g = g" src="//upload.wikimedia.org/math/4/3/7/4377a1dfbfeaf0ce1c1259dd4653addc.png" /></dd>
</dl>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=3" title="Edit section: Hask, the Haskell category">edit</a>]</span> <span class="mw-headline" id="Hask.2C_the_Haskell_category"><b>Hask</b>, the Haskell category</span></h3>
<p>The main category we’ll be concerning ourselves with in this article is <b>Hask</b>, the category of Haskell types and Haskell functions as morphisms, using <code>(.)</code> for composition: a function <code>f&#160;:: A -&gt; B</code> for types <code>A</code> and <code>B</code> is a morphism in <b>Hask</b>. We can check the first and second law easily: we know <code>(.)</code> is an associative function, and clearly, for any <code>f</code> and <code>g</code>, <code>f . g</code> is another function. In <b>Hask</b>, the identity morphism is <code>id</code>, and we have trivially:</p>
<dl>
<dd><code>id . f = f . id = f</code></dd>
</dl>
<p><sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup> This isn't an exact translation of the law above, though; we’re missing subscripts. The function <code>id</code> in Haskell is <i>polymorphic</i> - it can take many different types for its domain and range, or, in category-speak, can have many different source and target objects. But morphisms in category theory are by definition <i>monomorphic</i> - each morphism has one specific source object and one specific target object. A polymorphic Haskell function can be made monomorphic by specifying its type (<i>instantiating</i> with a monomorphic type), so it would be more precise if we said that the identity morphism from <b>Hask</b> on a type <code>A</code> is <code>(id&#160;:: A -&gt; A)</code>. With this in mind, the above law would be rewritten as:</p>
<dl>
<dd><code>(id&#160;:: B -&gt; B) . f = f . (id&#160;:: A -&gt; A) = f</code></dd>
</dl>
<p>However, for simplicity, we will ignore this distinction when the meaning is clear.</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>
<ul>
<li>As was mentioned, any partial order (<i>P</i>, <img class="tex" alt="\leq" src="//upload.wikimedia.org/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png" />) is a category with objects as the elements of <i>P</i> and a morphism between elements <i>a</i> and <i>b</i> iff a <img class="tex" alt="\leq" src="//upload.wikimedia.org/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png" /> b. Which of the above laws guarantees the transitivity of <img class="tex" alt="\leq" src="//upload.wikimedia.org/math/4/9/d/49dc1443f33cf63082d6e193dd2af78f.png" />?</li>
<li>(Harder.) If we add another morphism to the above example, it fails to be a category. Why? Hint: think about associativity of the composition operation.</li>
</ul>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Not-a-cat.png" class="image"><img alt="Not-a-cat.png" src="//upload.wikimedia.org/wikibooks/en/6/65/Not-a-cat.png" width="413" height="102" /></a></div>
</div>
</td>
</tr>
</table>
<h2><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=4" title="Edit section: Functors">edit</a>]</span> <span class="mw-headline" id="Functors">Functors</span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:438px;"><a href="/wiki/File:Functor.png" class="image"><img alt="" src="//upload.wikimedia.org/wikibooks/en/3/36/Functor.png" width="436" height="243" class="thumbimage" /></a>
<div class="thumbcaption">A functor between two categories, <img class="tex" alt="\mathbf{C}" src="//upload.wikimedia.org/math/3/9/6/39652eaf6bb68bf9769f17cb8088fece.png" /> and <img class="tex" alt="\mathbf{D}" src="//upload.wikimedia.org/math/5/b/7/5b711f39bd91a89cc7b4cb4ec592eaa7.png" />. Of note is that the objects <i>A</i> and <i>B</i> both get mapped to the same object in <img class="tex" alt="\mathbf{D}" src="//upload.wikimedia.org/math/5/b/7/5b711f39bd91a89cc7b4cb4ec592eaa7.png" />, and that therefore <i>g</i> becomes a morphism with the same source and target object (but isn't necessarily an identity), and <img class="tex" alt="id_A" src="//upload.wikimedia.org/math/d/a/5/da549742196d4375325bcc2b6a34e81b.png" /> and <img class="tex" alt="id_B" src="//upload.wikimedia.org/math/7/e/7/7e77be72d2f169d7cb8f64cb094acc24.png" /> become the same morphism. The arrows showing the mapping of objects are shown in a dotted, pale olive. The arrows showing the mapping of morphisms are shown in a dotted, pale blue.</div>
</div>
</div>
<p>So we have some categories which have objects and morphisms that relate our objects together. The next Big Topic in category theory is the <b>functor</b>, which relates categories together. A functor is essentially a transformation between categories, so given categories <i>C</i> and <i>D</i>, a functor <img class="tex" alt="F&#160;: C \to D" src="//upload.wikimedia.org/math/7/c/1/7c1286d4398218a18365ca450b93153d.png" />:</p>
<ul>
<li>Maps any object <i>A</i> in <i>C</i> to <img class="tex" alt="F(A)" src="//upload.wikimedia.org/math/1/8/7/18760c0431a2f869b624f1448cab54b4.png" />, in <i>D</i>.</li>
<li>Maps morphisms <img class="tex" alt="f&#160;: A \to B" src="//upload.wikimedia.org/math/e/0/f/e0fcfcf1bc30612af09825187fbbad7d.png" /> in <i>C</i> to <img class="tex" alt="F(f)&#160;: F(A) \to F(B)" src="//upload.wikimedia.org/math/f/2/a/f2a10a3930d7bf68a40950ae6ff833ed.png" /> in <i>D</i>.</li>
</ul>
<p>One of the canonical examples of a functor is the forgetful functor <img class="tex" alt="\mathbf{Grp} \to \mathbf{Set}" src="//upload.wikimedia.org/math/5/b/d/5bde71b5688459e65cb3f8445a80f74b.png" /> which maps groups to their underlying sets and group morphisms to the functions which behave the same but are defined on sets instead of groups. Another example is the power set functor <img class="tex" alt="\mathbf{Set} \to \mathbf{Set}" src="//upload.wikimedia.org/math/7/3/b/73be1783fc276dcb0e3e4b8345fd9f4d.png" /> which maps sets to their power sets and maps functions <img class="tex" alt="f&#160;: X \to Y" src="//upload.wikimedia.org/math/5/2/d/52d50404f827bbeee59ac8a21a1378b5.png" /> to functions <img class="tex" alt="\mathcal{P}(X) \to \mathcal{P}(Y)" src="//upload.wikimedia.org/math/1/0/9/1097d4564eb0d948f35dbe662679e582.png" /> which take inputs <img class="tex" alt="U \subseteq X" src="//upload.wikimedia.org/math/8/6/8/868e956a4a3f595f4ab7fe2f292e7084.png" /> and return <img class="tex" alt="f(U)" src="//upload.wikimedia.org/math/2/3/7/237dccd3133f35c013d7673ca2a706e8.png" />, the image of <i>U</i> under <i>f</i>, defined by <img class="tex" alt="f(U) = \{ \, f(u)&#160;: u \in U \, \}" src="//upload.wikimedia.org/math/0/c/0/0c05e76c4059c4f1496971ce186d732f.png" />. For any category <i>C</i>, we can define a functor known as the identity functor on <i>C</i>, or <img class="tex" alt="1_C&#160;: C \to C" src="//upload.wikimedia.org/math/5/7/6/5760ee02bbf644ff7fea1bbd7dcc04b0.png" />, that just maps objects to themselves and morphisms to themselves. This will turn out to be useful in the <a href="#The_monad_laws_and_their_importance">monad laws</a> section later on.</p>
<p>Once again there are a few axioms that functors have to obey. Firstly, given an identity morphism <img class="tex" alt="id_A" src="//upload.wikimedia.org/math/d/a/5/da549742196d4375325bcc2b6a34e81b.png" /> on an object <i>A</i>, <img class="tex" alt="F(id_A)" src="//upload.wikimedia.org/math/8/6/0/86077d384d7f3397c0f743aa600710c8.png" /> must be the identity morphism on <img class="tex" alt="F(A)" src="//upload.wikimedia.org/math/1/8/7/18760c0431a2f869b624f1448cab54b4.png" />, i.e.:</p>
<dl>
<dd><img class="tex" alt="F(id_A) = id_{F(A)}" src="//upload.wikimedia.org/math/9/2/8/92854188e6a61870cf427250ea46979c.png" /></dd>
</dl>
<p>Secondly functors must distribute over morphism composition, i.e.</p>
<dl>
<dd><img class="tex" alt="F(f \circ g) = F(f) \circ F(g)" src="//upload.wikimedia.org/math/2/8/4/284ad08d08e4fdfcd88bdf551c94de84.png" /></dd>
</dl>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>For the diagram given on the right, check these functor laws.</td>
</tr>
</table>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=5" title="Edit section: Functors on Hask">edit</a>]</span> <span class="mw-headline" id="Functors_on_Hask">Functors on <b>Hask</b></span></h3>
<p>The Functor typeclass you will probably have seen in Haskell does in fact tie in with the categorical notion of a functor. Remember that a functor has two parts: it maps objects in one category to objects in another and morphisms in the first category to morphisms in the second. Functors in Haskell are from <b>Hask</b> to <i>func</i>, where <i>func</i> is the subcategory of <b>Hask</b> defined on just that functor's types. E.g. the list functor goes from <b>Hask</b> to <b>Lst</b>, where <b>Lst</b> is the category containing only <i>list types</i>, that is, <code>[T]</code> for any type <code>T</code>. The morphisms in <b>Lst</b> are functions defined on list types, that is, functions <code>[T] -&gt; [U]</code> for types <code>T</code>, <code>U</code>. How does this tie into the Haskell typeclass Functor? Recall its definition:</p>
<pre>
class Functor (f :: * -&gt; *) where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</pre>
<p>Let's have a sample instance, too:</p>
<pre>
instance Functor Maybe where
  fmap f (Just x) = Just (f x)
  fmap _ Nothing  = Nothing
</pre>
<p>Here's the key part: the <i>type constructor</i> Maybe takes any type <code>T</code> to a new type, <code>Maybe T</code>. Also, <code>fmap</code> restricted to Maybe types takes a function <code>a -&gt; b</code> to a function <code>Maybe a -&gt; Maybe b</code>. But that's it! We've defined two parts, something that takes objects in <b>Hask</b> to objects in another category (that of Maybe types and functions defined on Maybe types), and something that takes morphisms in <b>Hask</b> to morphisms in this category. So Maybe is a functor.</p>
<p>A useful intuition regarding Haskell functors is that they represent types that can be mapped over. This could be a list or a Maybe, but also more complicated structures like trees. A function that does some mapping could be written using <code>fmap</code>, then any functor structure could be passed into this function. E.g. you could write a generic function that covers all of Data.List.map, Data.Map.map, Data.Array.IArray.amap, and so on.</p>
<p>What about the functor axioms? The polymorphic function <code>id</code> takes the place of <img class="tex" alt="id_A" src="//upload.wikimedia.org/math/d/a/5/da549742196d4375325bcc2b6a34e81b.png" /> for any <i>A</i>, so the first law states:</p>
<pre>
fmap id = id
</pre>
<p>With our above intuition in mind, this states that mapping over a structure doing nothing to each element is equivalent to doing nothing overall. Secondly, morphism composition is just <code>(.)</code>, so</p>
<pre>
fmap (f . g) = fmap f . fmap g
</pre>
<p>This second law is very useful in practice. Picturing the functor as a list or similar container, the right-hand side is a two-pass algorithm: we map over the structure, performing <code>g</code>, then map over it again, performing <code>f</code>. The functor axioms guarantee we can transform this into a single-pass algorithm that performs <code>f . g</code>. This is a process known as <i>fusion</i>.</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>Check the laws for the Maybe and list functors.</td>
</tr>
</table>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=6" title="Edit section: Translating categorical concepts into Haskell">edit</a>]</span> <span class="mw-headline" id="Translating_categorical_concepts_into_Haskell">Translating categorical concepts into Haskell</span></h3>
<p>Functors provide a good example of how category theory gets translated into Haskell. The key points to remember are that:</p>
<ul>
<li>We work in the category <b>Hask</b> and its subcategories.</li>
<li>Objects are types.</li>
<li>Morphisms are functions.</li>
<li>Things that take a type and return another type are type constructors.</li>
<li>Things that take a function and return another function are higher-order functions.</li>
<li>Typeclasses, along with the polymorphism they provide, make a nice way of capturing the fact that in category theory things are often defined over a number of objects at once.</li>
</ul>
<h2><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=7" title="Edit section: Monads">edit</a>]</span> <span class="mw-headline" id="Monads">Monads</span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:263px;"><a href="/wiki/File:Unit-join.png" class="image"><img alt="" src="//upload.wikimedia.org/wikibooks/en/b/b9/Unit-join.png" width="261" height="213" class="thumbimage" /></a>
<div class="thumbcaption"><i>unit</i> and <i>join</i>, the two morphisms that must exist for every object for a given monad.</div>
</div>
</div>
<p>Monads are obviously an extremely important concept in Haskell, and in fact they originally came from category theory. A <i>monad</i> is a special type of functor, from a category to that same category, that supports some additional structure. So, down to definitions. A monad is a functor <img class="tex" alt="M&#160;: C \to C" src="//upload.wikimedia.org/math/f/b/1/fb18d302e563839ddf6c4afe380823d3.png" />, along with two morphisms<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[2]</a></sup> for every object <i>X</i> in <i>C</i>:</p>
<ul>
<li><img class="tex" alt="\mathit{unit}^M_X&#160;: X \to M(X)" src="//upload.wikimedia.org/math/8/c/6/8c6393e5ecec35a7fb423372fcd65c96.png" /></li>
<li><img class="tex" alt="\mathit{join}^M_X&#160;: M(M(X)) \to M(X)" src="//upload.wikimedia.org/math/c/8/5/c8507c773b8cae170430309ef4e98873.png" /></li>
</ul>
<p>When the monad under discussion is obvious, we’ll leave out the <i>M</i> superscript for these functions and just talk about <img class="tex" alt="\mathit{unit}_X" src="//upload.wikimedia.org/math/4/3/d/43d2bfa4c774f5bef185a1e988f94b3a.png" /> and <img class="tex" alt="\mathit{join}_X" src="//upload.wikimedia.org/math/f/b/5/fb5850500ba25ce9f676831ec1ed1038.png" /> for some <i>X</i>.</p>
<p>Let’s see how this translates to the Haskell typeclass Monad, then.</p>
<pre>
class Functor m =&gt; Monad m where
  return :: a -&gt; m a
  (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b
</pre>
<p>The class constraint of <code>Functor m</code> ensures that we already have the functor structure: a mapping of objects and of morphisms. <code>return</code> is the (polymorphic) analogue to <img class="tex" alt="\mathit{unit}_X" src="//upload.wikimedia.org/math/4/3/d/43d2bfa4c774f5bef185a1e988f94b3a.png" /> for any <i>X</i>. But we have a problem. Although <code>return</code>’s type looks quite similar to that of <i>unit</i>; the other function, <code>(&gt;&gt;=)</code>, often called <i>bind</i>, bears no resemblance to <i>join</i>. There is however another monad function, <code>join&#160;:: Monad m =&gt; m (m a) -&gt; m a</code>, that looks quite similar. Indeed, we can recover <code>join</code> and <code>(&gt;&gt;=)</code> from each other:</p>
<pre>
join :: Monad m =&gt; m (m a) -&gt; m a
join x = x &gt;&gt;= id

(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
x &gt;&gt;= f = join (fmap f x)
</pre>
<p>So specifying a monad’s <code>return</code>, <code>fmap</code>, and <code>join</code> is equivalent to specifying its <code>return</code> and <code>(&gt;&gt;=)</code>. It just turns out that the normal way of defining a monad in category theory is to give <i>unit</i> and <i>join</i>, whereas Haskell programmers like to give <code>return</code> and <code>(&gt;&gt;=)</code>.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup> Often, the categorical way makes more sense. Any time you have some kind of structure <i>M</i> and a natural way of taking any object <i>X</i> into <img class="tex" alt="M(X)" src="//upload.wikimedia.org/math/d/f/a/dfad906f72bce48c6e81adbb040aec0b.png" />, as well as a way of taking <img class="tex" alt="M(M(X))" src="//upload.wikimedia.org/math/7/e/4/7e44d867d7718baeea17f3d555799d64.png" /> into <img class="tex" alt="M(X)" src="//upload.wikimedia.org/math/d/f/a/dfad906f72bce48c6e81adbb040aec0b.png" />, you probably have a monad. We can see this in the following example section.</p>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=8" title="Edit section: Example: the powerset functor is also a monad">edit</a>]</span> <span class="mw-headline" id="Example:_the_powerset_functor_is_also_a_monad">Example: the powerset functor is also a monad</span></h3>
<p>The power set functor <img class="tex" alt="P&#160;: \mathbf{Set} \to \mathbf{Set}" src="//upload.wikimedia.org/math/8/6/e/86e8c7e7e5372c4f7b1cf4002a023352.png" /> described above forms a monad. For any set <i>S</i> you have a <img class="tex" alt="\mathit{unit}_S(x) = \{x\}" src="//upload.wikimedia.org/math/5/b/3/5b30d52825da0b5f5e86d4af4eaf122f.png" />, mapping elements to their singleton set. Note that each of these singleton sets are trivially a subset of <i>S</i>, so <img class="tex" alt="\mathit{unit}_S" src="//upload.wikimedia.org/math/2/c/e/2ce53dd99d5cbdec0750d9a7782753d6.png" /> returns elements of the powerset of <i>S</i>, as is required. Also, you can define a function <img class="tex" alt="\mathit{join}_S" src="//upload.wikimedia.org/math/f/9/c/f9c4cdba36c956f89b9afabc17362a86.png" /> as follows: we receive an input <img class="tex" alt="L \in \mathcal{P}(\mathcal{P}(S))" src="//upload.wikimedia.org/math/a/8/a/a8a99104c8764f4192ec5ad2755ff8ad.png" />. This is:</p>
<ul>
<li>A member of the powerset of the powerset of <i>S</i>.</li>
<li>So a member of the set of all subsets of the set of all subsets of <i>S</i>.</li>
<li>So a set of subsets of <i>S</i></li>
</ul>
<p>We then return the union of these subsets, giving another subset of <i>S</i>. Symbolically,</p>
<dl>
<dd><img class="tex" alt="\mathit{join}_S(L) = \bigcup L" src="//upload.wikimedia.org/math/d/5/e/d5e441c24ead47568679437e3260b3c2.png" />.</dd>
</dl>
<p>Hence <i>P</i> is a monad <sup id="cite_ref-4" class="reference"><a href="#cite_note-4">[4]</a></sup>.</p>
<p>In fact, <i>P</i> is almost equivalent to the list monad; with the exception that we're talking lists instead of sets, they're almost the same. Compare:</p>
<p><br /></p>
<p><br /></p>
<table class="wikitable" width="100%">
<tr>
<th colspan="2" width="50%">Power set functor on <b>Set</b></th>
</tr>
<tr>
<th>Function type</th>
<th>Definition</th>
</tr>
<tr>
<td colspan="2">Given a set <i>S</i> and a morphism <img class="tex" alt="f&#160;: A \to B" src="//upload.wikimedia.org/math/e/0/f/e0fcfcf1bc30612af09825187fbbad7d.png" />:</td>
</tr>
<tr>
<td><img class="tex" alt="P(f)&#160;: \mathcal{P}(A) \to \mathcal{P}(B)" src="//upload.wikimedia.org/math/8/6/9/8696407a17bdea54ff9f4fb88282cfb0.png" /></td>
<td><img class="tex" alt="(P(f))(S) = \{ f(a)&#160;: a \in S \}" src="//upload.wikimedia.org/math/d/6/7/d67c258da8d72d74960ee3abb7d4ad76.png" /></td>
</tr>
<tr>
<td><img class="tex" alt="\mathit{unit}_S&#160;: S \to \mathcal{P}(S)" src="//upload.wikimedia.org/math/d/6/a/d6a0bcae34a12c1fd221f033e8fd0704.png" /></td>
<td><img class="tex" alt="\mathit{unit}_S(x) = \{ x \}" src="//upload.wikimedia.org/math/5/b/3/5b30d52825da0b5f5e86d4af4eaf122f.png" /></td>
</tr>
<tr>
<td><img class="tex" alt="\mathit{join}_S&#160;: \mathcal{P}(\mathcal{P}(S)) \to \mathcal{P}(S)" src="//upload.wikimedia.org/math/7/9/0/790c46274c45afe8ac49dd746291bb0c.png" /></td>
<td><img class="tex" alt="\mathit{join}_S(L) = \bigcup L" src="//upload.wikimedia.org/math/d/5/e/d5e441c24ead47568679437e3260b3c2.png" /></td>
</tr>
<tr>
<th colspan="2" width="50%">List monad from Haskell</th>
</tr>
<tr>
<th>Function type</th>
<th>Definition</th>
</tr>
<tr>
<td colspan="2">Given a type <code>T</code> and a function <code>f&#160;:: A -&gt; B</code></td>
</tr>
<tr>
<td><code>fmap f&#160;:: [A] -&gt; [B]</code></td>
<td><code>fmap f xs = [ f a | a &lt;- xs ]</code></td>
</tr>
<tr>
<td><code>return&#160;:: T -&gt; [T]</code></td>
<td><code>return x = [x]</code></td>
</tr>
<tr>
<td><code>join&#160;:: [[T]] -&gt; [T]</code></td>
<td><code>join xs = concat xs</code></td>
</tr>
</table>
<h2><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=9" title="Edit section: The monad laws and their importance">edit</a>]</span> <span class="mw-headline" id="The_monad_laws_and_their_importance">The monad laws and their importance</span></h2>
<p>Just as functors had to obey certain axioms in order to be called functors, monads have a few of their own. We'll first list them, then translate to Haskell, then see why they’re important.</p>
<p>Given a monad <img class="tex" alt="M&#160;: C \to C" src="//upload.wikimedia.org/math/f/b/1/fb18d302e563839ddf6c4afe380823d3.png" /> and a morphism <img class="tex" alt="f&#160;: A \to B" src="//upload.wikimedia.org/math/e/0/f/e0fcfcf1bc30612af09825187fbbad7d.png" /> for <img class="tex" alt="A, B \in C" src="//upload.wikimedia.org/math/4/9/8/498258d668f05b66a7d9eb3850b54af4.png" />,</p>
<ol>
<li><img class="tex" alt="\mathit{join} \circ M(\mathit{join}) = \mathit{join} \circ \mathit{join}" src="//upload.wikimedia.org/math/2/e/6/2e68d60e70fb627a82849bdcd85c739b.png" /></li>
<li><img class="tex" alt="\mathit{join} \circ M(\mathit{unit}) = \mathit{join} \circ \mathit{unit} = \mathit{id}" src="//upload.wikimedia.org/math/6/d/4/6d498922eabe90e5a570695f5da72536.png" /></li>
<li><img class="tex" alt="\mathit{unit} \circ f = M(f) \circ \mathit{unit}" src="//upload.wikimedia.org/math/e/4/0/e406ad5750c67dab0568fd8d9293fc26.png" /></li>
<li><img class="tex" alt="\mathit{join} \circ M(M(f)) = M(f) \circ \mathit{join}" src="//upload.wikimedia.org/math/a/7/0/a703891b667a8285461563e1b2f6cfd0.png" /></li>
</ol>
<p>By now, the Haskell translations should be hopefully self-explanatory:</p>
<ol>
<li><code>join . fmap join = join . join</code></li>
<li><code>join . fmap return = join . return = id</code></li>
<li><code>return . f = fmap f . return</code></li>
<li><code>join . fmap (fmap f) = fmap f . join</code></li>
</ol>
<p>(Remember that <code>fmap</code> is the part of a functor that acts on morphisms.) These laws seem a bit impenetrable at first, though. What on earth do these laws mean, and why should they be true for monads? Let’s explore the laws.</p>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=10" title="Edit section: The first law">edit</a>]</span> <span class="mw-headline" id="The_first_law">The first law</span></h3>
<p><code>join . fmap join = join . join</code></p>
<div class="thumb tright">
<div class="thumbinner" style="width:405px;"><a href="/wiki/File:Monad-law-1-lists.png" class="image"><img alt="" src="//upload.wikimedia.org/wikibooks/en/2/2f/Monad-law-1-lists.png" width="403" height="387" class="thumbimage" /></a>
<div class="thumbcaption">A demonstration of the first law for lists. Remember that <code>join</code> is <code>concat</code> and <code>fmap</code> is <code>map</code> in the list monad.</div>
</div>
</div>
<p>In order to understand this law, we'll first use the example of lists. The first law mentions two functions, <code>join . fmap join</code> (the left-hand side) and <code>join . join</code> (the right-hand side). What will the types of these functions be? Remembering that <code>join</code>’s type is <code>[[a]] -&gt; [a]</code> (we’re talking just about lists for now), the types are both <code>[[[a]]] -&gt; [a]</code> (the fact that they’re the same is handy; after all, we’re trying to show they’re completely the same function!). So we have a list of list of lists. The left-hand side, then, performs <code>fmap join</code> on this 3-layered list, then uses <code>join</code> on the result. <code>fmap</code> is just the familiar <code>map</code> for lists, so we first map across each of the list of lists inside the top-level list, concatenating them down into a list each. So afterward, we have a list of lists, which we then run through <code>join</code>. In summary, we 'enter' the top level, collapse the second and third levels down, then collapse this new level with the top level.</p>
<p>What about the right-hand side? We first run <code>join</code> on our list of list of lists. Although this is three layers, and you normally apply a two-layered list to <code>join</code>, this will still work, because a <code>[[[a]]]</code> is just <code>[[b]]</code>, where <code>b = [a]</code>, so in a sense, a three-layered list is just a two layered list, but rather than the last layer being 'flat', it is composed of another list. So if we apply our list of lists (of lists) to <code>join</code>, it will flatten those outer two layers into one. As the second layer wasn't flat but instead contained a third layer, we will still end up with a list of lists, which the other <code>join</code> flattens. Summing up, the left-hand side will flatten the inner two layers into a new layer, then flatten this with the outermost layer. The right-hand side will flatten the outer two layers, then flatten this with the innermost layer. These two operations should be equivalent. It’s sort of like a law of associativity for <code>join</code>.</p>
<p><code>Maybe</code> is also a monad, with</p>
<pre>
return :: a -&gt; Maybe a
return x = Just x

join :: Maybe (Maybe a) -&gt; Maybe a
join Nothing         = Nothing
join (Just Nothing)  = Nothing
join (Just (Just x)) = Just x
</pre>
<p>So if we had a <i>three</i>-layered Maybe (i.e., it could be <code>Nothing</code>, <code>Just Nothing</code>, <code>Just (Just Nothing)</code> or <code>Just (Just (Just x))</code>), the first law says that collapsing the inner two layers first, then that with the outer layer is exactly the same as collapsing the outer layers first, then that with the innermost layer.</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>Verify that the list and Maybe monads do in fact obey this law with some examples to see precisely how the layer flattening works.</td>
</tr>
</table>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=11" title="Edit section: The second law">edit</a>]</span> <span class="mw-headline" id="The_second_law">The second law</span></h3>
<p><code>join . fmap return = join . return = id</code></p>
<p>What about the second law, then? Again, we'll start with the example of lists. Both functions mentioned in the second law are functions <code>[a] -&gt; [a]</code>. The left-hand side expresses a function that maps over the list, turning each element <code>x</code> into its singleton list <code>[x]</code>, so that at the end we’re left with a list of singleton lists. This two-layered list is flattened down into a single-layer list again using the <code>join</code>. The right hand side, however, takes the entire list <code>[x, y, z, ...]</code>, turns it into the singleton list of lists <code>[[x, y, z, ...]]</code>, then flattens the two layers down into one again. This law is less obvious to state quickly, but it essentially says that applying <code>return</code> to a monadic value, then <code>join</code>ing the result should have the same effect whether you perform the <code>return</code> from inside the top layer or from outside it.</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>Prove this second law for the Maybe monad.</td>
</tr>
</table>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=12" title="Edit section: The third and fourth laws">edit</a>]</span> <span class="mw-headline" id="The_third_and_fourth_laws">The third and fourth laws</span></h3>
<p><code>return . f = fmap f . return</code></p>
<p><code>join . fmap (fmap f) = fmap f . join</code></p>
<p>The last two laws express more self evident fact about how we expect monads to behave. The easiest way to see how they are true is to expand them to use the expanded form:</p>
<ol>
<li><code>\x -&gt; return (f x) = \x -&gt; fmap f (return x)</code></li>
<li><code>\x -&gt; join (fmap (fmap f) x) = \x -&gt; fmap f (join x)</code></li>
</ol>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>Convince yourself that these laws should hold true for any monad by exploring what they mean, in a similar style to how we explained the first and second laws.</td>
</tr>
</table>
<h3><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=13" title="Edit section: Application to do-blocks">edit</a>]</span> <span class="mw-headline" id="Application_to_do-blocks">Application to do-blocks</span></h3>
<p>Well, we have intuitive statements about the laws that a monad must support, but why is that important? The answer becomes obvious when we consider do-blocks. Recall that a do-block is just syntactic sugar for a combination of statements involving <code>(&gt;&gt;=)</code> as witnessed by the usual translation:</p>
<pre>
do { x }                 --&gt;  x
do { let { y = v }; x }  --&gt;  let y = v in do { x }
do { v &lt;- y; x }         --&gt;  y &gt;&gt;= \v -&gt; do { x }
do { y; x }              --&gt;  y &gt;&gt;= \_ -&gt; do { x }
</pre>
<p>Also notice that we can prove what are normally quoted as the monad laws using <code>return</code> and <code>(&gt;&gt;=)</code> from our above laws (the proofs are a little heavy in some cases, feel free to skip them if you want to):</p>
<ol>
<li><code>return x &gt;&gt;= f = f x</code>. Proof:
<pre>
   return x &gt;&gt;= f
 = join (fmap f (return x)) -- By the definition of (&gt;&gt;=)
 = join (return (f x))      -- By law 3
 = (join . return) (f x)
 = id (f x)                 -- By law 2
 = f x
</pre></li>
<li>
<p><code>m &gt;&gt;= return = m</code>. Proof:</p>
<pre>
  m &gt;&gt;= return
= join (fmap return m)    -- By the definition of (&gt;&gt;=)
= (join . fmap return) m
= id m                    -- By law 2
= m
</pre></li>
<li>
<p><code>(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code>. Proof (recall that <code>fmap f . fmap g = fmap (f . g)</code>):</p>
<pre>
  (m &gt;&gt;= f) &gt;&gt;= g
= (join (fmap f m)) &gt;&gt;= g                          -- By the definition of (&gt;&gt;=)
= join (fmap g (join (fmap f m)))                  -- By the definition of (&gt;&gt;=)
= (join . fmap g) (join (fmap f m))
= (join . fmap g . join) (fmap f m)
= (join . join . fmap (fmap g)) (fmap f m)         -- By law 4
= (join . join . fmap (fmap g) . fmap f) m
= (join . join . fmap (fmap g . f)) m              -- By the distributive law of functors
= (join . join . fmap (\x -&gt; fmap g (f x))) m
= (join . fmap join . fmap (\x -&gt; fmap g (f x))) m -- By law 1
= (join . fmap (join . (\x -&gt; fmap g (f x)))) m    -- By the distributive law of functors
= (join . fmap (\x -&gt; join (fmap g (f x)))) m
= (join . fmap (\x -&gt; f x &gt;&gt;= g)) m                -- By the definition of (&gt;&gt;=)
= join (fmap (\x -&gt; f x &gt;&gt;= g) m)
= m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)                          -- By the definition of (&gt;&gt;=)
</pre></li>
</ol>
<p>These new monad laws, using <code>return</code> and <code>(&gt;&gt;=)</code>, can be translated into do-block notation.</p>
<table class="wikitable" style="margin: 1em auto">
<tr>
<th>Points-free style</th>
<th>Do-block style</th>
</tr>
<tr>
<td><code>return x &gt;&gt;= f = f x</code></td>
<td><code>do { v &lt;- return x; f v } = do { f x }</code></td>
</tr>
<tr>
<td><code>m &gt;&gt;= return = m</code></td>
<td><code>do { v &lt;- m; return v } = do { m }</code></td>
</tr>
<tr>
<td><code>(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></td>
<td>
<pre>
   do { y &lt;- do { x &lt;- m; f x };
        g y }
 =
   do { x &lt;- m;
        y &lt;- f x;
        g y }
</pre></td>
</tr>
</table>
<p>The monad laws are now common-sense statements about how do-blocks should function. If one of these laws were invalidated, users would become confused, as you couldn't be able to manipulate things within the do-blocks as would be expected. The monad laws are, in essence, usability guidelines.</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;">
<tr>
<th>Exercises</th>
</tr>
<tr>
<td>
<p>In fact, the two versions of the laws we gave:</p>
<pre>
-- Categorical:
join . fmap join = join . join
join . fmap return = join . return = id
return . f = fmap f . return
join . fmap (fmap f) = fmap f . join

-- Functional:
m &gt;&gt;= return = m
return m &gt;&gt;= f = f m
(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
</pre>
<p>are entirely equivalent. We showed that we can recover the functional laws from the categorical ones. Go the other way; show that starting from the functional laws, the categorical laws hold. It may be useful to remember the following definitions:</p>
<pre>
join m = m &gt;&gt;= id
fmap f m = m &gt;&gt;= return . f
</pre>
Thanks to Yitzchak Gale for suggesting this exercise.</td>
</tr>
</table>
<h2><span class="editsection">[<a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit&amp;section=14" title="Edit section: Summary">edit</a>]</span> <span class="mw-headline" id="Summary">Summary</span></h2>
<p>We've come a long way in this chapter. We've looked at what categories are and how they apply to Haskell. We've introduced the basic concepts of category theory including functors, as well as some more advanced topics like monads, and seen how they're crucial to idiomatic Haskell. We haven't covered some of the basic category theory that wasn't needed for our aims, like natural transformations, but have instead provided an intuitive feel for the categorical grounding behind Haskell's structures.</p>
<h2><span class="editsection">[<a href="/w/index.php?title=Template:Haskell/NotesSection&amp;action=edit&amp;section=T-1" title="Template:Haskell/NotesSection">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h2>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite_ref-1">↑</a></span> <span class="reference-text">Actually, there is a subtlety here: because <code>(.)</code> is a lazy function, if <code>f</code> is <code>undefined</code>, we have that <code>id . f = \_ -&gt; _|_</code>. Now, while this may seem equivalent to <code>_|_</code> for all intents and purposes, you can actually tell them apart using the strictifying function <code>seq</code>, meaning that the last category law is broken. We can define a new strict composition function, <code>f .! g = ((.) $! f) $! g</code>, that makes <b>Hask</b> a category. We proceed by using the normal <code>(.)</code>, though, and attribute any discrepancies to the fact that <code>seq</code> breaks an awful lot of the nice language properties anyway.</span></li>
<li id="cite_note-2"><span class="mw-cite-backlink"><a href="#cite_ref-2">↑</a></span> <span class="reference-text">Experienced category theorists will notice that we're simplifying things a bit here; instead of presenting <i>unit</i> and <i>join</i> as natural transformations, we treat them explicitly as morphisms, and require naturality as extra axioms alongside the <a href="#The_third_and_fourth_laws">standard monad laws (laws 3 and 4)</a>. The reasoning is simplicity; we are not trying to teach category theory as a whole, simply give a categorical background to some of the structures in Haskell. You may also notice that we are giving these morphisms names suggestive of their Haskell analogues, because the names <img class="tex" alt="\eta" src="//upload.wikimedia.org/math/7/1/7/7174cbd6aeaaa56e37102b72386bb2b9.png" /> and <img class="tex" alt="\mu" src="//upload.wikimedia.org/math/b/7/2/b72bb92668acc30b4474caff40274044.png" /> don’t provide much intuition.</span></li>
<li id="cite_note-3"><span class="mw-cite-backlink"><a href="#cite_ref-3">↑</a></span> <span class="reference-text">This is perhaps due to the fact that Haskell programmers like to think of monads as a way of sequencing computations with a common feature, whereas in category theory the container aspect of the various structures is emphasised. <code>join</code> pertains naturally to containers (squashing two layers of a container down into one), but <code>(&gt;&gt;=)</code> is the natural sequencing operation (do something, feeding its results into something else).</span></li>
<li id="cite_note-4"><span class="mw-cite-backlink"><a href="#cite_ref-4">↑</a></span> <span class="reference-text">If you can prove that certain laws hold, which we'll explore in the next section.</span></li>
</ol>
<p><br /></p>
<div class="noprint">
<center>
<table cellpadding="1" style="border: 1px solid #8888aa; background: #f7f8ff; padding: 5px; font-size: 95%; margin: 0 15px 0 15px;">
<tr>
<td style="background: #ccf; text-align: center;"><b>Category theory</b></td>
</tr>
<tr>
<td style="text-align:center"><a href="/w/index.php?title=Haskell/Solutions/Category_theory&amp;action=edit&amp;redlink=1" class="new" title="Haskell/Solutions/Category theory (does not exist)">Solutions to exercises</a></td>
</tr>
<tr>
<td style="background: #ccf; text-align: center;"><b>Wider Theory</b></td>
</tr>
<tr>
<td style="text-align:center">
<p><a href="/wiki/Haskell/Denotational_semantics" title="Haskell/Denotational semantics">Denotational semantics</a> <a href="/wiki/File:75%25.svg" class="image"><img alt="75%.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/4/49/75%25.svg/9px-75%25.svg.png" width="9" height="9" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/4/49/75%25.svg/14px-75%25.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/4/49/75%25.svg/18px-75%25.svg.png 2x" /></a> &#160;&gt;&gt;&#160;<a href="/w/index.php?title=Haskell/Equational_reasoning&amp;action=edit&amp;redlink=1" class="new" title="Haskell/Equational reasoning (does not exist)">Equational reasoning</a> &#160;&gt;&gt;&#160;<a href="/w/index.php?title=Haskell/Program_derivation&amp;action=edit&amp;redlink=1" class="new" title="Haskell/Program derivation (does not exist)">Program derivation</a> &#160;&gt;&gt;&#160;<strong class="selflink">Category theory</strong> <a href="/wiki/File:100%25.svg" class="image"><img alt="100%.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/9px-100%25.svg.png" width="9" height="9" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/14px-100%25.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/18px-100%25.svg.png 2x" /></a> &#160;&gt;&gt;&#160;<a href="/wiki/Haskell/The_Curry-Howard_isomorphism" title="Haskell/The Curry-Howard isomorphism">The Curry-Howard isomorphism</a> &#160;&gt;&gt;&#160;<a href="/wiki/Haskell/Fix_and_recursion" title="Haskell/Fix and recursion">fix and recursion</a> <a href="/wiki/File:100%25.svg" class="image"><img alt="100%.svg" src="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/9px-100%25.svg.png" width="9" height="9" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/14px-100%25.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/c/ce/100%25.svg/18px-100%25.svg.png 2x" /></a></p>
<div style="clear:both;"><small class="noprint"><a class="external text" href="//en.wikibooks.org/w/index.php?title=Template:Haskell_chapter/Wider_Theory&amp;action=edit">edit this chapter</a></small></div>
<p><br /></p>
</td>
</tr>
<tr>
<td style="background: #ccf; text-align: center;"><b><a href="/wiki/Haskell" title="Haskell">Haskell</a></b></td>
</tr>
<tr>
<td style="text-align:center">
<p><a href="/wiki/Haskell/Haskell_Basics" title="Haskell/Haskell Basics" class="mw-redirect">Haskell Basics</a> &gt;&gt; <a href="/wiki/Haskell/Elementary_Haskell" title="Haskell/Elementary Haskell" class="mw-redirect">Elementary Haskell</a> &gt;&gt; <a href="/wiki/Haskell/Intermediate_Haskell" title="Haskell/Intermediate Haskell" class="mw-redirect">Intermediate Haskell</a> &gt;&gt; <a href="/wiki/Haskell/Monads" title="Haskell/Monads" class="mw-redirect">Monads</a><br />
<a href="/wiki/Haskell/Advanced_Haskell" title="Haskell/Advanced Haskell" class="mw-redirect">Advanced Haskell</a> &gt;&gt; <a href="/wiki/Haskell/Fun_with_Types" title="Haskell/Fun with Types" class="mw-redirect">Fun with Types</a> &gt;&gt; <a href="/wiki/Haskell/Wider_Theory" title="Haskell/Wider Theory" class="mw-redirect">Wider Theory</a> &gt;&gt; <a href="/wiki/Haskell/Haskell_Performance" title="Haskell/Haskell Performance" class="mw-redirect">Haskell Performance</a><br /></p>
<hr />
<p><a href="/wiki/Haskell/Libraries_Reference" title="Haskell/Libraries Reference" class="mw-redirect">Libraries Reference</a> &gt;&gt; <a href="/wiki/Haskell/General_Practices" title="Haskell/General Practices" class="mw-redirect">General Practices</a> &gt;&gt; <a href="/wiki/Haskell/Specialised_Tasks" title="Haskell/Specialised Tasks" class="mw-redirect">Specialised Tasks</a></p>
<div style="float:right;"><small><small class="noprint"><a class="external text" href="//en.wikibooks.org/w/index.php?title=Template:Haskell_navigation&amp;action=edit">edit book structure</a></small></small></div>
</td>
</tr>
</table>
</center>
</div>


<!-- 
NewPP limit report
Preprocessor visited node count: 1092/1000000
Preprocessor generated node count: 3164/1500000
Post-expand include size: 8093/2048000 bytes
Template argument size: 1776/2048000 bytes
Highest expansion depth: 7/40
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwikibooks:pcache:idhash:107278-0!0!0!default!!en!4!* and timestamp 20130122212253 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://en.wikibooks.org/w/index.php?title=Haskell/Category_theory&amp;oldid=2432486">http://en.wikibooks.org/w/index.php?title=Haskell/Category_theory&amp;oldid=2432486</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/wiki/Category:Haskell" title="Category:Haskell">Haskell</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<!-- header -->
			<div id="mw-head" class="noprint">
				
<!-- 0 -->
<div id="p-personal" role="navigation" class="">
	<h3>Personal tools</h3>
	<ul>
<li id="pt-createaccount"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Haskell%2FCategory+theory&amp;type=signup">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Haskell%2FCategory+theory" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>	</ul>
</div>

<!-- /0 -->
				<div id="left-navigation">
					
<!-- 0 -->
<div id="p-namespaces" role="navigation" class="vectorTabs">
	<h3>Namespaces</h3>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/Haskell/Category_theory"  title="View the content page [c]" accesskey="c">Book</a></span></li>
					<li  id="ca-talk"><span><a href="/wiki/Talk:Haskell/Category_theory"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3><span>Variants</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
				</div>
				<div id="right-navigation">
					
<!-- 0 -->
<div id="p-views" role="navigation" class="vectorTabs">
	<h3>Views</h3>
	<ul>
					<li id="ca-view" class="selected"><span><a href="/wiki/Haskell/Category_theory" >Read</a></span></li>
					<li id="ca-edit"><span><a href="/w/index.php?title=Haskell/Category_theory&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/w/index.php?title=Haskell/Category_theory&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet">
	<h3><span>Actions</span><a href="#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search" role="search">
	<h3><label for="searchInput">Search</label></h3>
	<form action="/w/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" title="Search Wikibooks [f]" accesskey="f" id="searchInput" />						<button type="submit" name="button" title="Search the pages for this text" id="searchButton"><img src="//bits.wikimedia.org/static-1.21wmf9/skins/vector/images/search-ltr.png?303-4" alt="Search" width="12" height="13" /></button>								<input type='hidden' name="title" value="Special:Search"/>
		</div>
	</form>
</div>

<!-- /2 -->
				</div>
			</div>
			<!-- /header -->
			<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo" role="banner"><a style="background-image: url(//upload.wikimedia.org/wikibooks/en/b/bc/Wiki.png);" href="/wiki/Main_Page"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- Navigation -->
<div class="portal" role="navigation" id='p-Navigation'>
	<h3>Navigation</h3>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-help"><a href="/wiki/Help:Contents" title="Find help on how to use and edit Wikibooks">Help</a></li>
			<li id="n-Browse"><a href="/wiki/Wikibooks:Card_Catalog_Office" title="Check out what Wikibooks has to offer">Browse</a></li>
			<li id="n-Cookbook"><a href="/wiki/Cookbook:Table_of_Contents" title="Learn recipes from around the world">Cookbook</a></li>
			<li id="n-Wikijunior"><a href="/wiki/Wikijunior" title="Books for children">Wikijunior</a></li>
			<li id="n-Featured-books"><a href="/wiki/Wikibooks:Featured_books" title="The best of Wikibooks">Featured books</a></li>
			<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-sitesupport"><a href="//donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikibooks.org&amp;uselang=en" title="Support Wikibooks">Donations</a></li>
			<li id="n-randomrootpage"><a href="/wiki/Special:Randomrootpage">Random book</a></li>
		</ul>
	</div>
</div>

<!-- /Navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- Community -->
<div class="portal" role="navigation" id='p-Community'>
	<h3>Community</h3>
	<div class="body">
		<ul>
			<li id="n-Reading-room"><a href="/wiki/Wikibooks:Reading_room" title="Discuss Wikibooks-related questions and concerns with others">Reading room</a></li>
			<li id="n-portal"><a href="/wiki/Wikibooks:Community_Portal" title="Find your way around the Wikibooks community">Community portal</a></li>
			<li id="n-currentevents"><a href="/wiki/Wikibooks:Reading_room/Bulletin_Board" title="Important community news">Bulletin Board</a></li>
			<li id="n-maintenance"><a href="/wiki/Wikibooks:Maintenance" title="Frequent tasks that you can help with">Help out!</a></li>
			<li id="n-Policies-and-guidelines"><a href="/wiki/Wikibooks:Policies_and_guidelines" title="Pages detailing important rules and procedures">Policies and guidelines</a></li>
			<li id="n-contact"><a href="/wiki/Wikibooks:Contact_us" title="Alternative methods of communication">Contact us</a></li>
		</ul>
	</div>
</div>

<!-- /Community -->

<!-- TOOLBOX -->
<div class="portal" role="navigation" id='p-tb'>
	<h3>Toolbox</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Haskell/Category_theory" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Haskell/Category_theory" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-upload"><a href="//commons.wikimedia.org/wiki/Commons:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
			<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li id="t-permalink"><a href="/w/index.php?title=Haskell/Category_theory&amp;oldid=2432486" title="Permanent link to this revision of the page">Permanent link</a></li>
			<li id="t-info"><a href="/w/index.php?title=Haskell/Category_theory&amp;action=info">Page information</a></li>
<li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Haskell%2FCategory_theory&amp;id=2432486" title="Information on how to cite this page">Cite this page</a></li>		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" role="navigation" id='p-lang'>
	<h3>In other languages</h3>
	<div class="body">
		<ul>
			<li class="interwiki-ja"><a href="//ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96" title="Haskell/圏論" lang="ja" hreflang="ja">日本語</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->

<!-- Sister projects -->
<div class="portal" role="navigation" id='p-Sister_projects'>
	<h3>Sister projects</h3>
	<div class="body">
		<ul>
			<li id="n-Wikipedia"><a href="//en.wikipedia.org/wiki/Main_Page">Wikipedia</a></li>
			<li id="n-Wikiversity"><a href="//en.wikiversity.org/wiki/Wikiversity:Main_Page">Wikiversity</a></li>
			<li id="n-Wiktionary"><a href="//en.wiktionary.org/wiki/Wiktionary:Main_Page">Wiktionary</a></li>
			<li id="n-Wikiquote"><a href="//en.wikiquote.org/wiki/Main_Page">Wikiquote</a></li>
			<li id="n-Wikisource"><a href="//en.wikisource.org/wiki/Main_Page">Wikisource</a></li>
			<li id="n-Wikinews"><a href="//en.wikinews.org/wiki/Main_Page">Wikinews</a></li>
			<li id="n-Wikivoyage"><a href="//en.wikivoyage.org/wiki/Main_Page">Wikivoyage</a></li>
			<li id="n-Commons"><a href="//commons.wikimedia.org/wiki/Main_Page">Commons</a></li>
		</ul>
	</div>
</div>

<!-- /Sister projects -->

<!-- coll-print_export -->
<div class="portal" role="navigation" id='p-coll-print_export'>
	<h3>Print/export</h3>
	<div class="body">
		<ul id="collectionPortletList"><li id="coll-create_a_book"><a href="/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=Haskell%2FCategory+theory" title="Create a book or page collection" rel="nofollow">Create a collection</a></li><li id="coll-download-as-rl"><a href="/w/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=Haskell%2FCategory+theory&amp;oldid=2432486&amp;writer=rl" title="Download a PDF version of this wiki page" rel="nofollow">Download as PDF</a></li><li id="t-print"><a href="/w/index.php?title=Haskell/Category_theory&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li></ul>	</div>
</div>

<!-- /coll-print_export -->
			</div>
			<!-- /panel -->
		</div>
		<!-- footer -->
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 2 November 2012, at 00:21.</li>
											<li id="footer-info-copyright">Text is available under the <a rel="license" href="//en.wikibooks.org/wiki/Wikibooks:Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/" style="display:none;"></a>;
additional terms may apply. See <a href="//wikimediafoundation.org/wiki/Terms_of_Use">Terms of Use</a> for details.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="//wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/Wikibooks:Welcome" title="Wikibooks:Welcome">About Wikibooks</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/Wikibooks:General_disclaimer" title="Wikibooks:General disclaimer">Disclaimers</a></li>
											<li id="footer-places-mobileview"><a href="http://en.m.wikibooks.org/wiki/Haskell/Category_theory" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="//wikimediafoundation.org/"><img src="//bits.wikimedia.org/images/wikimedia-button.png" width="88" height="31" alt="Wikimedia Foundation"/></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="//www.mediawiki.org/"><img src="//bits.wikimedia.org/static-1.21wmf9/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script src="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=skins.vector&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mobile.desktop","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.extlinks","mw.MwEmbedSupport.style","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.editWarning","mw.PopUpMediaTransform","ext.flaggedRevs.advanced"], null, true);
}</script>
<script src="/w/index.php?title=MediaWiki:Gadget-commons-file.js&amp;action=raw&amp;ctype=text/javascript&amp;2172780"></script>
<script src="/w/index.php?title=MediaWiki:Gadget-toolboxcompat.js&amp;action=raw&amp;ctype=text/javascript&amp;2161931"></script>
<script src="//bits.wikimedia.org/en.wikibooks.org/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<!-- Served by mw1064 in 0.114 secs. -->
	</body>
</html>
